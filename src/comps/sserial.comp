#ifdef CMD_TX
#error at the moment you can only have one component using the tx channel of the command port
#else
#define CMD_TX
#endif

#ifdef CMD_RX
#error you can only have one command compound
#else
#define CMD_RX
#endif

COMP(sserial);

//dump:
//sigrok-cli --driver fx2lafw --config samplerate=24m --time 1s --channels 3=rx,2=tx -t rx=f -o sserial.sr
//decode:
//sigrok-cli -i sserial.sr -P uart:baudrate=2500000:tx=tx:rx=rx:format=hex -A uart=tx-data:rx-data
//decode more:
//sigrok-cli -i sserial.sr -P uart:baudrate=2500000:tx=tx:rx=rx,sserial

#define UnitNumberRPC 0xbc
#define DiscoveryRPC 0xbb
#define ProcessDataRPC 0xbd

//local commands
#define LBPCookieCMD 0xdf
#define LBPCookie 0x5a

#define LBPStatusCMD 0xc1

#define LBPCardName "STMB"
#define LBPCardName0Cmd 0xd0
#define LBPCardName1Cmd 0xd1
#define LBPCardName2Cmd 0xd2
#define LBPCardName3Cmd 0xd3

#define CT_RW     1 // 01b
#define CT_RPC    2 // 10b
#define CT_LOCAL  3 // 11b

typedef union{
    struct {
        uint8_t ds:2;//DataSize: Specifies data size, 00b = 1 bytes, 01b = 2 bytes, 10 b= 4 bytes, 11b = 8 bytes.
        uint8_t as:1;//AddressSize: 0 to specify current address, 1 to specify 2 byte address.
        uint8_t ai:1;//AutoInc: 0 leaves address unchanged, 1 specifies that address is post incremented by data size in bytes.
        uint8_t rid:1;//RPCIncludesData: 0 specifies that data is from stream, 1, that data is from RPC (RPC only, ignored for non RPC commands)
        uint8_t wr:1;//Write: 1 to specify write, 0 to specify read
        uint8_t ct:2;//CommandType: Must be 01b to specify data read/write command
        // 01:rw   11:local command   10:rpc
    };
    struct {
        uint8_t rpc:6;
        uint8_t dummy:2;
        //01:rw 11: local command 10:rpc
    };
    uint8_t byte;
} lbp_t;

//process data
#define RECORD_TYPE_PROCESS_DATA_RECORD 0xA0
#define DATA_TYPE_PAD 0x00
#define DATA_TYPE_BITS 0x01
#define DATA_TYPE_UNSIGNED 0x02
#define DATA_TYPE_SIGNED 0x03
#define DATA_TYPE_NONVOL_UNSIGNED 0x04
#define DATA_TYPE_NONVOL_SIGNED 0x05
#define DATA_TYPE_NONVOL_STREAM 0x06
#define DATA_TYPE_NONVOL_BOOLEAN 0x07

#define DATA_DIRECTION_INPUT 0x00
#define DATA_DIRECTION_BI_DIRECTIONAL 0x40
#define DATA_DIRECTION_OUTPUT 0x80

//modes
#define RECORD_TYPE_MODE_DATA_RECORD 0xB0

#define MAX_PD_STRLEN 32 // this is the max space for both the unit and name strings in the PD descriptors
#define MAX_PD_VAL_BYTES 64 // this should be >= the sum of the data sizes of all pd vars

#define NO_MODES 2//gtoc modes
#define NO_GPD 1//gtoc process data
#define NO_PD 2//process data

#define MEMPTR(p) ((uint32_t)&p-(uint32_t)&memory)

#define MEMU8(ptr) (memory.bytes[ptr])
#define MEMU16(ptr) (memory.bytes[ptr] | memory.bytes[ptr+1]<<8)
#define MEMU32(ptr) (memory.bytes[ptr] | memory.bytes[ptr+1]<<8 | memory.bytes[ptr+2]<<16 | memory.bytes[ptr+3]<<24)


typedef struct{
   uint8_t record_type;//0xa0
   uint8_t data_size;
   uint8_t data_type;
   uint8_t data_direction;
   float param_min;
   float param_max;
   uint16_t data_add;
   char names[MAX_PD_STRLEN];
} process_data_descriptor_t;

typedef struct{
   uint8_t record_type;//0xb0
   uint8_t index;
   uint8_t type;
   uint8_t unused;
   char name_string[4];
} mode_descriptor_t;

typedef struct{
   uint8_t input;
   uint8_t output;
   uint16_t ptocp;//pointer to process data table
   uint16_t gtocp;//pointer to mode data table
} discovery_rpc_t;

typedef struct{
   mode_descriptor_t md[NO_MODES];
   process_data_descriptor_t pd[NO_GPD];
   uint16_t eot;//end of table
} gtoc_t;

typedef struct{
   process_data_descriptor_t pd[NO_PD];
   uint16_t eot;//end of table
} ptoc_t;


typedef union {
 struct {
   uint8_t start;
   // the tocs are terminated by 0x0000 entries, hence the +1
   uint16_t ptocp[NO_PD+1];
   uint16_t gtocp[NO_GPD+NO_MODES+1];
   ptoc_t ptoc;
   gtoc_t gtoc;
   uint8_t pd_values[MAX_PD_VAL_BYTES];
   uint8_t end;
 };
 uint8_t bytes[1024];
} memory_t;

MEM(volatile uint8_t rxbuf[128]);
MEM(volatile uint8_t txbuf[20]);
MEM(int rxpos);
MEM(memory_t memory);
MEM(discovery_rpc_t discovery_rpc);
MEM(uint8_t datasize[4]);

void add_pd(uint8_t *pd_num, uint16_t *param_addr, uint8_t data_size_in_bits, uint8_t data_type, uint8_t data_dir, 
      uint32_t param_min, uint32_t param_max, char *unit_string, char *name_string) {

  uint8_t i = *pd_num;

  memory.ptoc.pd[i].record_type = RECORD_TYPE_PROCESS_DATA_RECORD;
  memory.ptoc.pd[i].data_size = data_size_in_bits;
  memory.ptoc.pd[i].data_type = data_type;
  memory.ptoc.pd[i].data_direction = data_dir;
  memory.ptoc.pd[i].param_min = param_min;
  memory.ptoc.pd[i].param_max = param_max;
  memory.ptoc.pd[i].data_add = *param_addr;
  strncpy(memory.ptoc.pd[i].names, unit_string, strlen(unit_string));
  strncpy(memory.ptoc.pd[i].names + strlen(unit_string) + 1, name_string, strlen(name_string));

  memory.ptocp[i] = MEMPTR(memory.ptoc.pd[i]);

  *pd_num += 1;

  // increment the param address based on the size of the data in bits
  uint8_t num_bytes = data_size_in_bits / 8 + (data_size_in_bits % 8 > 0 ? 1 : 0);

  if (data_dir != 0x00) {
    discovery_rpc.input += num_bytes;
  }

  if (data_dir != 0x80) {
    discovery_rpc.output += num_bytes;
  }

  *param_addr += num_bytes;
}


// gtoc_idx is the index of the gpd or mode within the gtoc.  We can add gpds and modes in any order, and the gtoc will read them back
// in that order.   It's passed by value because the functions don't modify it.  It's passed in as the sum of the current gpd_num and mode_num.
void add_gpd(uint8_t *pd_num, uint8_t gtoc_idx, uint16_t *param_addr, uint8_t data_size_in_bits, uint8_t data_type, uint8_t data_dir, 
      uint32_t param_min, uint32_t param_max, char *unit_string, char *name_string) {

  uint8_t i = *pd_num;

  memory.gtoc.pd[i].record_type = RECORD_TYPE_PROCESS_DATA_RECORD;
  memory.gtoc.pd[i].data_size = data_size_in_bits;
  memory.gtoc.pd[i].data_type = data_type;
  memory.gtoc.pd[i].data_direction = data_dir;
  memory.gtoc.pd[i].param_min = param_min;
  memory.gtoc.pd[i].param_max = param_max;
  memory.gtoc.pd[i].data_add = *param_addr;
  strncpy(memory.gtoc.pd[i].names, unit_string, strlen(unit_string));
  strncpy(memory.gtoc.pd[i].names + strlen(unit_string) + 1, name_string, strlen(name_string));

  memory.gtocp[gtoc_idx] = MEMPTR(memory.gtoc.pd[i]);

  *pd_num += 1;

  // increment the param address based on the size of the data in bits
  uint8_t num_bytes = data_size_in_bits / 8 + (data_size_in_bits % 8 > 0 ? 1 : 0);

  *param_addr += num_bytes;
}

void add_mode(uint8_t *mode_num, uint8_t gtoc_idx, uint8_t index, uint8_t type, char *name_string) {
  uint8_t i = *mode_num;

  memory.gtoc.md[i].record_type = RECORD_TYPE_MODE_DATA_RECORD;
  memory.gtoc.md[i].index = index;
  memory.gtoc.md[i].type = type;
  memory.gtoc.md[i].unused = 0x00;
  strncpy(memory.gtoc.md[i].name_string, name_string, strlen(name_string));

  memory.gtocp[gtoc_idx] = MEMPTR(memory.gtoc.md[i]);

  *mode_num += 1;
}

//pb13 txen
//pc12 usart5 tx
//pa9 usart1 tx as rx

INIT(
   GPIO_InitTypeDef GPIO_InitStruct;
   USART_InitTypeDef USART_InitStruct;
   RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
   RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOA, ENABLE);
   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOB, ENABLE);
   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOC, ENABLE);

   //USART TX
   GPIO_PinAFConfig(GPIOC, GPIO_PinSource12, GPIO_AF_UART5);
   GPIO_InitStruct.GPIO_Pin = GPIO_Pin_12;
   GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF;
   GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
   GPIO_InitStruct.GPIO_OType = GPIO_OType_PP;
   GPIO_InitStruct.GPIO_PuPd = GPIO_PuPd_UP ;
   GPIO_Init(GPIOC, &GPIO_InitStruct);
   
   GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_OUT;
   GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
   GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
   GPIO_InitStructure.GPIO_PuPd  = GPIO_PuPd_NOPULL;
   GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_13;
   GPIO_Init(GPIOB, &GPIO_InitStructure);

   //USART RX
   GPIO_PinAFConfig(GPIOA, GPIO_PinSource9, GPIO_AF_USART1);
   GPIO_InitStruct.GPIO_Pin = GPIO_Pin_9;
   GPIO_Init(GPIOA, &GPIO_InitStruct);

   USART_InitStruct.USART_BaudRate = 2500000;
   USART_InitStruct.USART_WordLength = USART_WordLength_8b;
   USART_InitStruct.USART_StopBits = USART_StopBits_1;
   USART_InitStruct.USART_Parity = USART_Parity_No;
   USART_InitStruct.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
   USART_InitStruct.USART_Mode = USART_Mode_Rx;
   USART_Init(USART1, &USART_InitStruct);
   USART_HalfDuplexCmd(USART1,ENABLE);
   
   USART_InitStruct.USART_Mode = USART_Mode_Tx;
   USART_Init(UART5, &USART_InitStruct);

   USART_Cmd(USART1, ENABLE);
   USART_Cmd(UART5, ENABLE);

   //RX DMA
   // Clock Enable
   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA2, ENABLE);

   DMA_Cmd(DMA2_Stream5, DISABLE);
   DMA_DeInit(DMA2_Stream5);

   // DMA2-Config
   DMA_InitStructure.DMA_Channel = DMA_Channel_4;
   DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&(USART1->DR);
   DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&rxbuf;
   DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
   DMA_InitStructure.DMA_BufferSize = sizeof(rxbuf);
   DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
   DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
   DMA_InitStructure.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;
   DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
   DMA_InitStructure.DMA_Priority = DMA_Priority_High;
   DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;
   DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
   DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
   DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
   DMA_Init(DMA2_Stream5, &DMA_InitStructure);

   DMA_Cmd(DMA2_Stream5, ENABLE);

   USART_DMACmd(USART1, USART_DMAReq_Rx, ENABLE);
   
   //TX DMA
   // Clock Enable
   RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_DMA1, ENABLE);

   DMA_Cmd(DMA1_Stream7, DISABLE);
   DMA_DeInit(DMA1_Stream7);

   // DMA2-Config
   DMA_InitStructure.DMA_Channel = DMA_Channel_4;
   DMA_InitStructure.DMA_PeripheralBaseAddr = (uint32_t)&(UART5->DR);
   DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)&txbuf;
   DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
   DMA_InitStructure.DMA_BufferSize = sizeof(txbuf);
   DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
   DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
   DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
   DMA_InitStructure.DMA_MemoryDataSize = DMA_PeripheralDataSize_Byte;
   DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
   DMA_InitStructure.DMA_Priority = DMA_Priority_High;
   DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;
   DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
   DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
   DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
   DMA_Init(DMA1_Stream7, &DMA_InitStructure);

   //DMA_Cmd(DMA1_Stream7, ENABLE);

   USART_DMACmd(UART5, USART_DMAReq_Tx, ENABLE);
   
   GPIO_SetBits(GPIOB, GPIO_Pin_13);//tx enable
   
   rxpos = 0;

   uint16_t param_addr = MEMPTR(memory.pd_values);
   uint8_t pd_num = 0;
   uint8_t gpd_num = 0;
   uint8_t mode_num = 0;

   // we increment these in add_pd
   discovery_rpc.input = 1; // 1 because the fault byte will always be present.
   discovery_rpc.output = 0;

   add_pd(&pd_num, &param_addr, 16, DATA_TYPE_UNSIGNED, DATA_DIRECTION_OUTPUT, 0, 0, "rps", "cmd_vel");
   add_pd(&pd_num, &param_addr, 8, DATA_TYPE_UNSIGNED, DATA_DIRECTION_INPUT, 0, 0, "rps", "fb_vel");

   add_gpd(&gpd_num, gpd_num + mode_num, &param_addr, 8, DATA_TYPE_UNSIGNED, DATA_DIRECTION_OUTPUT, 0, 0, "non", "swr");

   add_mode(&mode_num, gpd_num + mode_num, 0, 0, "foo");
   add_mode(&mode_num, gpd_num + mode_num, 1, 1, "io_");

   memory.ptoc.eot = 0x0000;
   memory.gtoc.eot = 0x0000;

   memory.ptocp[pd_num] = 0x0000;
   memory.gtocp[gpd_num + mode_num] = 0x0000; 

   discovery_rpc.ptocp = MEMPTR(memory.ptocp);
   discovery_rpc.gtocp = MEMPTR(memory.gtocp);
);

uint8_t crc8( uint8_t *addr, uint8_t len)
{
   uint8_t crc=0;
   for (uint8_t i=0; i<len;i++)
   {
      uint8_t inbyte = addr[i];
      for (uint8_t j=0;j<8;j++)
      {
         uint8_t mix = (crc ^ inbyte) & 0x01;
         crc >>= 1;
         if (mix)
            crc ^= 0x8C;
         inbyte >>= 1;
      }
   }
   return crc;
}

void send(uint8_t len, uint8_t docrc){
   if(docrc){
      txbuf[len] = crc8((uint8_t *)txbuf,len);
      DMA_SetCurrDataCounter(DMA1_Stream7,len+1);
   }else{
      DMA_SetCurrDataCounter(DMA1_Stream7,len);
   }
   DMA_Cmd(DMA1_Stream7, DISABLE);
   DMA_ClearFlag(DMA1_Stream7, DMA_FLAG_TCIF7);
   DMA_Cmd(DMA1_Stream7, ENABLE);
}

FRT(
   //uint8_t buf[100];
   uint16_t address = 0;
   lbp_t lbp;
   
   char name[] = LBPCardName;
   int bufferpos;
   int available;
   for(int j = 0;j<2;j++){
   bufferpos = sizeof(rxbuf) - DMA_GetCurrDataCounter(DMA2_Stream5);
   available = (bufferpos - rxpos + sizeof(rxbuf)) % sizeof(rxbuf);
   
   if (available >= 1) { //TODO: somtimes more data is needed, needs check
      
      lbp.byte = rxbuf[rxpos];

      if (lbp.ct == CT_LOCAL && lbp.wr == 0 && available >= 2) { //local read, 2b
         switch(lbp.byte) {
            case LBPCookieCMD:
              txbuf[0] = LBPCookie;
              break;
            
            case LBPStatusCMD: //TODO: return status
              txbuf[0] = 0x00;
              break;
            
            case LBPCardName0Cmd ... LBPCardName3Cmd:
              txbuf[0] = name[lbp.byte-LBPCardName0Cmd];
              break;

            default: //TODO: handle unknown command condition
              txbuf[0] = 0x00;
         }
         send(1,1);
         rxpos += 2;
      }else if(lbp.ct == CT_LOCAL && lbp.wr == 1 && available >= 2){//local write, 3b
         if(rxbuf[rxpos] == 0xff){
            // reset parser
            rxpos += 1;
         }else if(rxbuf[rxpos] == 0xFC){
            // todo
            rxpos += 1;
         }else if(available >= 3){
            txbuf[0] = 0x00;
            send(1,0);
            rxpos += 3;  
         }
      }else if(lbp.ct == CT_RPC){//RPC
          if(lbp.byte == UnitNumberRPC && available >= 2){//unit number, 2b
              txbuf[0] = 0x76;
              txbuf[1] = 0x01;
              txbuf[2] = 0x00;
              txbuf[3] = 0x10;
              send(4,1);
              rxpos += 2;
          }else if(lbp.byte == DiscoveryRPC && available >= 2){//discovery, 2b
             for(int i = 0;i < sizeof(discovery_rpc);i++){
                txbuf[i] = ((uint8_t*)&discovery_rpc)[i];
             }
              send(sizeof(discovery_rpc),1);
              rxpos += 2;
          }else if(lbp.byte == ProcessDataRPC && available >= discovery_rpc.output + 2){//process data, requires cmd+output+crc
             txbuf[0] = 0x00;//TODO: transfer real pd
             txbuf[1] = 0x00;
             txbuf[2] = 0x00;
             txbuf[3] = 0x00;
             txbuf[4] = 0x00;
             txbuf[5] = 0x00;
             send(discovery_rpc.input,1);
             rxpos += discovery_rpc.output + 2;
          }
      } else if (lbp.ct == CT_RW && lbp.wr == 0 && available >= 2) { //read
          if (lbp.as == 1) { // 4b
             if (available >= 4) {
                address = rxbuf[(rxpos+1)%sizeof(rxbuf)] + (rxbuf[(rxpos+2)%sizeof(rxbuf)]<<8);
                rxpos += 4;
                for(int i = 0;i < datasize[lbp.ds];i++){//TODO: maybe faster to change DMA pointer?
                   txbuf[i] = memory.bytes[address+i];
                }
                send(datasize[lbp.ds],1);
                if(lbp.ai == 1){
                    address++;
                }
             }
          } else { // 2b
              rxpos += 2;
              for(int i = 0;i < datasize[lbp.ds];i++){
                 txbuf[i] = memory.bytes[address+i];
              }
              send(datasize[lbp.ds],1);
              if(lbp.ai == 1){
                  address++;
              }
          }
      } else {
         //TODO: handle unkown packet
      }
   }
   rxpos = rxpos % sizeof(rxbuf);
}
);

ENDCOMP;
